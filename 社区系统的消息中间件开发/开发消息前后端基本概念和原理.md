# [`WebSocket`]什么是`WebSocket`？

<img src="/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-18 22.25.21.png" alt="截屏2020-08-18 22.25.21" style="zoom:50%;" />

`http`有如下几点劣势：

+ `HTTP`是无状态的，如果需要实现类似聊天室的应用，那么我们必须每几秒钟就往服务端发送发送请求，但是这种请求基本都是查询的，对服务端来讲没有新提交的数据的更新，因此在一个大型系统中是非常耗费系统资源、网路资源的；
+ `http`是无法连续监听数据更新的，及时更新的数据是不能及时到达的，如果这次数据请求发现没有数据更新，但是数据返回到调用方后后立马数据库的数据更新了，那么离下次请求之间会有一个时间差，用户友好度很差；

那么，`WebSocket`有哪些优势呢？

+ `webSocket`是长连接的协议，更好地节省系统资源和带宽，支持实时的数据通信；
+ `webSocket`就是为双向通信所设计的，系统资源的耗费来自于对数据的操作，如果`webSocket`上并没有对系统资源的使用，那么是不存在系统资源的浪费的；同时，虽然双方存在连接，但是如果双向之间没有数据的传输，那么信道就是空的，自然也是不存在带宽的使用的，也就是不存在浪费；

那么什么是`WebSocket`？`WebSocket`是一种网络传输协议，可在单个`TCP`连接上进行全双工通信，位于`OSI`模型的应用层；

他有以下特点：

+ `TCP`，与`HTTP`协议兼容；
+ 双向通信，服务端向客户端主动推送；
+ 无同源限制，协议标识符是`ws`，同时支持安全加密通信`wss`；
+ 支持

那么他有哪些应用场景呢？

+ 聊天、消息、点赞；
+ 直播评论（弹幕）；
+ 游戏、协同编辑、基于位置的应用；

# [`wsebSocket`]

在前端，有几个常用的用于实现`WebSocket`的库：

+ `ws`：实现原生协议，没有封装其他的功能，通用，性能高，定制性强；
+ `socket.io`：向下兼容协议，如果目标浏览器不支持`WebSocket`，那么会自动使用`ajax`、`http`来模拟`WebSocket`，适配性强，但是性能一般；

`WebSocket`对各个浏览器以及版本的适配性，我们发现已经有`95.88%`的浏览器适配了`WebSocket`，重点要注意`IE`版本必须`>9`，因此在传统项目中如果要使用`WebSocket`，那么请使用`socket.io`这个库；

![截屏2020-08-18 23.05.43](/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-18 23.05.43.png)

同时，我们可以使用`npm trend`来对比这几个库；

<img src="/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-18 23.08.46.png" alt="截屏2020-08-18 23.08.46" style="zoom:50%;" />

我们发现这样几个事实：

+ `ws`的下载量远大于其他`socket.io`；
+ `ws`的`issues`远少于`socket.io`，更加稳定；

同时，因为`socket.io`比`ws`封装了更多，更加适合初学者学习；

<img src="/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-18 23.11.40.png" alt="截屏2020-08-18 23.11.40" style="zoom:50%;" />

从上图中，我们发现`ws`的通信效率远大于`socket.io`，通信成本远低于`socket.io`；

因此，不管怎么样，都推荐优先使用`ws`；

# [`Vs Code`]`@go live`来加载`html`代码文件

如果当前你处于`html`文件的页面，那么你可以使用`vs code`的`Go Live`功能，他会将你的`html`文件加载进来，同时打开系统默认浏览器来加载它；

![截屏2020-08-18 23.25.23](/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-18 23.25.23.png)

# [`WebSocket`]第一个`WebSocket`的例子

`WebSocket`在`node`环境、浏览器环境`html`、服务器环境中都可以使用；

首先我们需要建立一个`WebSocket`服务器，这样其他的服务才能接入到我们的`WebSocket`服务中；

```js
const WebSocket = require('ws') //引用库

//创建一个WebSocket服务器，设定端口为当前主机的3000
const ws = new WebSocket.Server({
    port: 3000
})

//当新的连接连接过来时触发回调，一定要分清楚connection和open的区别
//传递的ws代表当前这支连接的ws，不会和其他的连接到WebSocket的协议混淆
ws.on('connection', function connection(ws) {
    console.log('client is connected to Server') //当一个协议连接到服务器时打印消息
    //当接受到当前协议的message时触发回调，可以接受一个event参数
    ws.on('message', function (event) {
        console.log(msg)
    })
    //主动发送消息到当前协议的客户端的方法
    ws.send('hello from server')
})
```

接着，我们就可以定义客户端的连接了；

由于在`浏览器`和`node`环境中使用的规范不同，因此`webSocket`提供了两套方法来实现在`浏览器`和`node`环境中`WebSocket`连接到服务器；

首先是在浏览器环境中：

```html
<!DOCTYPE html>
<html lang="en">
  ...
  <body>
    <script>
      //创建一个连接到服务器的连接
      var ws = new WebSocket('ws://127.0.0.1:3000')
      //打开连接的回调函数，当连接到服务器时调用
      ws.onopen = function () {
        ws.send('hello from client')
      }
      //当服务器有消息传递回来时回调，可以传递event参数来表示传递的信息
      ws.onmessage = function (event) {
        console.log(event.data)
      }
    </script>
  </body>
</html>
```

接着在`node`环境中我们这样写：

```js
const WebSocket = require('ws')

//连接到服务器
const ws = new WebSocket('ws:127.0.0.1:3000')

ws.on('open', function () {
    //当打开连接时发送消息
    ws.send('client say hello to server')
})

//当服务端发送消息回来时回调
ws.on('message', function (event) {
        console.log(msg)
})
```

和浏览器环境的写法略有一点点区别；

服务器端因为会同时有多个协议连接过来因此必须采用闭包的形式来书写；

# [`WebSocket`]`socket.io`的使用（难点：如何理解`socket`？）

`socket.io`和`ws`库有稍些区别，一般要求在`express`、`koa`等框架环境中使用`socket.io`；

首先我们搭建服务器；

```js
const app = require('express')() //使用express的方法创建一个实例
const http = require('http').createServer(app) 
//创建一个http服务实例，将app传递进去作为处理器，接受所有的http的请求进行处理
const io = require('socket.io')(http) 
//第一次socket握手需要使用http，因此需要挂到http实例上，实际上是为http添加了一些新的请求处理
//如，io会监听http获得的/socket.io/socket.io.js的文件请求，并将服务器node_modules中的socket.io-client/dist/socket.io.js文件返回
//如下面html代码中的socket.io.js就是通过socket进行请求处理并返回文件的

//当接受到/请求时，发送html页面
app.get('/', function (req, res) {
    //发送前端代码
    res.sendFile(__dirname + '/index.html')
})

//当有协议连接了，就触发回调
io.on('connection', function (socket) {
    console.log("a socket is connected!")
})

//http服务监听3000端口
http.listen(3000, function () {
    console.log("server is running on : 3000")
})
```

接着，在前端的代码中，我们这样写：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="/socket.io/socket.io.js"></script>
    <!--等价于 const io = require('socket.io-client'); -->
    <script>
        var socket = io() // 创建即连接
        //这个连接默认请求到url：window.location:http，在这里是//localhost:3000
        //默认的请求路径path是socket.io
    </script>
</head>

<body>
    Hello Server
</body>

</html>
```

`      var socket = io()`在执行时，`socket.io`会使用两次`http`请求来提升协议，即从`http`协议升级到`socket`协议，这也是为什么需要将`/socket.io`的请求路径添加到服务器上的原因，目的就是使用两次`http`请求来升级协议，如果升级成功，`io`就成功地和服务器之间创建一个长连接，连接的请求路径是`ws://localhost:3000/socket.io`；

<img src="/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-20 23.32.09.png" alt="截屏2020-08-20 23.32.09" style="zoom:50%;" />

其实`WebSocket`技术并不是`HTTP`时代难以实现的技术，只是为了安全起见防止服务器滥发广告等恶心的商业行为；

要转变思想去理解`WebSocket`协议，其实只要服务器随时知道接收者的另一端是谁就行，而不是只有接受者来询问服务器时才知道，因此就需要保存连接状态，让服务器具有往这个连接发送请求的能力；`io`组件在我们的`socket`信道连接成功后，就保持对连接的掌控，而可以往这个信道传输数据；重点就是长时间的掌控信道，因为`HTTP`就是因为连接在不断的创建与销毁导致无法再次往`HTTP`连接中发送数据的；

在完成`socket`握手连接之后，浏览器端的`io`组件和服务器端的`io`组件就会对生成的`socket`信道进行监听和收发数据，这样就可以全双工通信了；

> 当你的`socket`服务器离线了，客户端会收到断线的消息，然后会不停尝试断线重连，这也是一个非常棒的特性；

更多相关知识参考`https://www.jianshu.com/p/4e80b931cdea`、`https://www.cnblogs.com/zhaosq/p/10854974.html`，这两篇文章对`WebSocket`有一个详细的讲解；

# [`CDN`]`StaticFile.org CDN`的使用

`StaticFile.org`是一个尽量完全的`CDN`站点，收录了许多的`CDN`网站，比如我们可以搜索使用`socket.io`的`CDN`；

然后可以直接在我们的代码中使用；

![截屏2020-08-20 23.31.34](/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-20 23.31.34.png)

# [`socket.io`]`socket.io`实现聊天室

其实，一个简单的聊天室，就是一个`socket`服务器上有若干个终端（每一个`tab`页面都是一个终端）连接，然后当有一个用户往`socket`服务器中发送消息，其他的终端都能够广播接收到，这样不就是一个简单的聊天室了吗？

`socket.io`相比`ws`封装了更多的`api`，考虑到了断线重连、数据封装、用户广播等等，这些都是原生`ws`不存在的特性，但是为了学习，仍然推荐从`ws`开始学起；

`socket.io`支持自定义事件，可以不使用`send`方法而自定义化传输的数据内容与性质，在浏览器端，我们这样来自定义往`socket`服务器上发送一个自定义事件：

```
 socket.emit("chatEvent", value) //往socket服务器发送chatEvent事件
```

当然，在浏览器端可以接受`socket`服务器返回除`message`外的自定义事件；

```
  socket.on('ServerMsg', function (msg) { //监听ServerMsg事件
            console.log(msg);
        })
```

而在服务器端，我们也去接受和发送自定义事件，并且我们可以广播我们的消息到除当前连接的用户外的终端上：

```
//当有协议连接了，就触发回调
io.on('connection', function (socket) {
    console.log("a socket is connected!")
    socket.on('chatEvent', function (msg) { //接受浏览器端的chatEvent事件
        console.log('msg from client:' + msg)
        // socket.send('server says:' + msg)
        socket.broadcast.emit('ServerMsg', msg) //广播消息不会发送给自己，会被连接上的其他用户得到
    })
})
```

一个简单的聊天室应用的代码如下：

`html`页面这么写：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.staticfile.org/socket.io/2.3.0/socket.io.js"></script>
    <!--等价于 const io = require('socket.io-client'); -->

</head>

<body>
    <input type="text" id="msg">
    <button type="button" id="btn">发送</button>
    <script>
        var socket = io() // 创建即连接
        document.getElementById("btn").addEventListener("click", function () {
            var value = document.getElementById("msg").value
            socket.emit("chatEvent", value) //往socket服务器发送chatEvent事件
            document.getElementById("msg").value = ''
        })

        // socket.on('message', function (msg) {
        //    console.log(msg);
        //})
        socket.on('ServerMsg', function (msg) {
            console.log(msg);
        })
    </script>
</body>

</html>
```

服务器这样写：

```js
const app = require('express')() //使用express的方法创建一个实例
const http = require('http').createServer(app)
//创建一个http服务实例，将app传递进去作为处理器
const io = require('socket.io')(http)
//第一次socket握手需要使用http，因此需要挂到http服务器上

//当接受到/请求时，发送html页面
app.get('/', function (req, res) {
    //发送前端代码
    res.sendFile(__dirname + '/index.html')
})

//当有协议连接了，就触发回调
io.on('connection', function (socket) {
    console.log("a socket is connected!")
    socket.on('chatEvent', function (msg) {
        console.log('msg from client:' + msg)
        // socket.send('server says:' + msg)
        socket.broadcast.emit('ServerMsg', msg) //广播消息不会发送给自己，会被连接上的其他用户
    })
})

//http服务监听3000端口
http.listen(3000, function () {
    console.log("server is running on : 3000")
})
```

你可以创建三个终端尝试一下，你会发现一个用户的消息被其他用户接受到了；

# [`websocket`]四种基本`ws`状态

`socket.io`用四种状态来代表当前浏览器侧的连接状态：

+ `WebSocket.CONNECTING`：正在连接状态(0)；
+ `WebSocket.OPEN`：打开状态(1)；
+ `WebSocket.CLOSING`：关闭状态(2)；
+ `WebSocket.CLOSED`：已关闭状态(3)；

在我们平常主要使用的`API`中，我们可以获得当前浏览器侧的连接状态；

```
        var socket = new WebSocket('ws://127.0.0.1:3000')
        //当浏览器侧socket打开时
        socket.onopen = function () {
            console.log("open:" + socket.readyState); // 1
            console.log("Hello from client!");
        }
        //当浏览器侧主动close事件
        socket.onclose = function () {
            console.log("close :" + socket.readyState); //3
            console.log("close the socket");
        }
        //当浏览器侧收到数据时
        socket.onmessage = function (event) {
            console.log("message:" + socket.readyState); //1
            console.log(event.data);
        }
        //当浏览器侧连接不上socket时
        socket.onerror = function () {
            console.log("error" + socket.readyState); //3
            console.log("连接失败");
        }
        document.getElementById("app").addEventListener("click", function () {
            socket.close() //主动关闭浏览器侧连接
        })
```

# [`WebSocket`、`Chrome`]在`Chrome`中查看`socket`连接情况

打开控制台，找到`socket`的网络连接请求，就可以查看连接过程中的数据往来情况了；

绿色向上箭头代表本地发出的数据，红色向下箭头代表服务器发过来的数据；

![截屏2020-08-22 01.21.14](/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-22 01.21.14.png)

# [`Vue`]在普通`html`工程中引入`Vue`

如果想要在自己公司原来的一个`html`项目上使用`vue`，我们需要走以下几个步骤；

+ 引入`vue`的核心代码文件，一般我们会使用`vue.min.js`，这是`vue`压缩后的核心代码文件；
+ 创建一个`id`为`app`的元素，这个元素会成为`vue`工作的域（`app`和其所包含的所有组件都会纳入`vue`管理的范围）；
+ 按照以前的写法，创建一个`vue`对象，并将其绑定到`id`为`app`的元素上；
+ 然后就可以和往常一样在`app`元素下书写`vue`指令、在`vue`对象中书写`vue`属性、方法了；

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="http://cdn.staticfile.org/vue/2.6.12/vue.min.js"></script>
    <title>Document</title>
  </head>

  <body>
    <div id="app">
      <ul>
        <li v-for="(item , index) in lists" :key="'message'+index">{{item}}</li>
      </ul>
      <div class="ctrl">
        <input type="text" id="msg" v-model="message" />
        <button type="button" id="send" @click="send()">发送</button>
        <button type="button" id="close">关闭连接</button>
      </div>
    </div>
    <script>
      var app = new Vue({
        el: '#app',
        data: {
          message: '',
          lists: [],
          ws: {},
        },
        mounted() {
          this.ws = new WebSocket('ws://127.0.0.1:3000')
          this.ws.onopen = this.onOpen
          this.ws.onmessage = this.onMessage
          this.ws.onerror = this.onError
          this.ws.onclose = this.onClose
        },
        methods: {
          onOpen() {
            this.lists.push('欢迎您进入直播间')
            console.log('open:' + this.ws.readyState)
          },
          onMessage(event) {
            this.lists.push(event.data)
          },
          onClose() {
            console.log('close :' + this.ws.readyState)
            console.log('close the socket connection.')
          },
          onError() {
            console.log('error' + this.ws.readyState)
            console.log('连接失败')
          },
          send() {
            this.lists.push(this.message)
            this.ws.send(this.message)
            this.message = ''
          },
        },
      })
    </script>
  </body>
</html>
```

# [`WebSocket`]`ws`实现基本聊天室

## 消息广播

如何实现一个消息广播，其实非常简单；

当一个连接的用户发送了一条消息时，我们希望将这条消息广播当除发送人之外所有用户终端上；

后端`ws`提供了`ws.client`方法来获取当前连接的所有的用户；

得益于闭包的能力，我们能在用户端和服务器产生`connection`时（调用`connection`监听函数）创建对该支连接的消息的`message`监听事件，并且同时得到一个带有当前连接信息的`client`对象，来代表当前客户端；

我们能在闭包于`connection`监听事件中的`message`监听事件中获取`client`对象，进而能够和`ws.client`获取的所有的对象进行一一对比来排除当前的`client`，这样我们就能够保证用户的消息能广播到所有除发送人外的终端了；

同时要注意，`ws.on('message',function(msg){})`中的回调函数的参数就是一则消息，没有其他的信息；

```js
const WebSocket = require('ws') //引用库

const wss = new WebSocket.Server({
    port: 3000,
})

//当新的连接连接过来时触发回调
wss.on('connection', function connection(ws) {
    console.log('client is connected to Server')
    //对当前的连接进行监听,msg是传递的message内容
    ws.on('message', function (msg) {
        // ws.send('server:' + msg)
        //获取所有的连接的用户
        wss.clients.forEach((client) => {
            //判断非自己的客户端并且该连接处于打开状态
            if (ws !== client && client.readyState === WebSocket.OPEN)
                client.send(msg)
        })
    })
})
```

## 进入聊天室欢迎语

我们往后端服务器传递的信息往往不是一个单一的字符串，而是一个有众多数据的对象，比如下面的例子是一个典型的多字段的消息；

```
{
  event:'enter' //指明事件类型
  message:'' //要发送的消息
}
```

但是`ws.send()`只支持`Blob`、字符串、底层二进制数据等类型的数据，不支持`Object`，因此需要使用`JSON.stringify()`进行字符串化；

当用户进入聊天室，我们希望其他的用户知道这个用户进入聊天室了，因此还是需要使用消息广播的能力，这部分基本就和第一部分是一致的；

为了开发聊天室欢迎语功能，我们传递这样一个消息，消息内容如下：

```
{
  event:'enter' //表示当前的消息类型为enter
  message:'demodemo' //存储要发送的当前进入直播间的人名
}
```

然后当用户进入聊天室时发送这个消息就行了，服务器会头也不回地将这个消息转发到其他所有的用户终端上；

```
 //当用户进入聊天室中执行
 enter(){
   if(this.name.trim() === ''){
      alert('用户名不得为空')
      return;
   }
   this.isShow = false
   //发送文本字符串、底层二进制数据、Blob，但是不能发送对象
   this.ws.send(JSON.stringify({
   event:'enter',
   message: this.name
   }))
},
```

因此终端上也要做一些操作，根据当前的消息类型来选择显示不同的信息；

```
  onMessage(event) { //event是一个完整的事件对象，取数据要从event.data中获取
            if(this.isShow)  return
            var obj = JSON.parse(event.data) //解析消息数据
            if(obj.event === 'enter'){  //如果是欢迎消息
                 this.lists.push("欢迎: "+obj.message+" 进入直播间")
            }else
              this.lists.push(obj.message) //直接显示消息
          },
```

完整代码如下：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="http://cdn.staticfile.org/vue/2.6.12/vue.min.js"></script>
    <title>Document</title>
  </head>

  <body>
    <div id="app">
        <div v-if="isShow">
                    <input type="text" v-model="name"></input>
                    <button type="button" @click="enter()">进入聊天室</button>
        </div>
        <div v-else>
              <ul>
                  <li v-for="(item , index) in lists" :key="'message'+index">{{item}}</li>
              </ul>
              <div class="ctrl">
                  <input type="text" id="msg" v-model="message" />
                  <button type="button" id="send" @click="send()">发送</button>
                  <button type="button" id="close">关闭连接</button>
              </div>
        </div>  
    </div>
    <script>
      var app = new Vue({
        el: '#app',
        data: {
          message: '',
          lists: [],
          ws: {},
          name:"",
          isShow:true
        },
        mounted() {
          this.ws = new WebSocket('ws://127.0.0.1:3000')
          this.ws.onopen = this.onOpen
          this.ws.onmessage = this.onMessage
          this.ws.onerror = this.onError
          this.ws.onclose = this.onClose
        },
        methods: {
          enter(){
                if(this.name.trim() === ''){
                    alert('用户名不得为空')
                    return;
                }
                this.isShow = false
                //发送文本字符串、底层二进制数据、Blob，但是不能发送对象
                this.ws.send(JSON.stringify({
                    event:'enter',
                    message: this.name
                }))
            },
          onOpen() {
            console.log('open:' + this.ws.readyState)
          },
          //接受到服务器传递回来的event对象，event.data是服务器传递回来的数据
          onMessage(event) {
            if(this.isShow)  return
            var obj = JSON.parse(event.data)
            if(obj.event === 'enter'){
                 this.lists.push("欢迎: "+obj.message+" 进入直播间")
            }else
              this.lists.push(obj.message)
          },
          onClose() {
            console.log('close :' + this.ws.readyState)
            console.log('close the socket connection.')
          },
          onError() {
            console.log('error' + this.ws.readyState)
            console.log('连接失败')
          },
          send() {
            this.lists.push(this.message)
            this.ws.send(JSON.stringify(
            {
                event:'message',
                message:this.message 
            }
            ))
            this.message = ''
          },
        },
      })
    </script>
  </body>
</html>
```

## 用户信息存储

当一个用户发送消息后，我们希望将它推送到所有的用户，并且能够带上当前用户的信息，比如`name`；

那么我们怎么做呢？有两种方法来实现；

+ 每一次用户发送消息时，我们将其`name`保存在要发送的数据以字符串形式发送给服务器，然后服务器将该字符串数据转发给其他用户，其他用户在该数据中获取用户的`name`信息；

  ```js
    this.ws.send(JSON.stringify(
    {
      event:'message',
      message:this.message,
      name:this.name
    }))
  ```

  但是这种方式过于笨重，我们每一次都需要将该用户信息发送出去，而这些信息都是刚进入聊天室就存在的长时间不变动的信息，其实我们可以直接保存在服务器上；

+ 我们可以将用户长久不变的信息直接保存在服务器上，每一次消息发送时连带需要的信息即可；

  当用户进入聊天室时，我们会发送一个`enter`事件到服务器上，这是一个存储用户信息到服务器上的好时机，我们就在这时将该用户的信息如`name`以消息的形式发送到服务器上；

  ```js
   enter(){
     if(this.name.trim() === ''){
       alert('用户名不得为空')
       return;
     }
     this.isShow = false
       //发送文本字符串、底层二进制数据、Blob，但是不能发送对象
       this.ws.send(JSON.stringify({
       event:'enter',
       message: this.name
     }))
  },
  ```

  我们知道，服务器在创建连接时回分配一个`ws`的对象来表示当前的用户，那么我们可以在用户进入聊天室发送`enter`事件类型的消息时将用户信息读取出来，然后挂到`ws`对象下；

  接着当我们需要将消息转发到其他的用户时，将用户信息放在要发送的消息上即可；

  ```js
   ws.on('message', function (msg) {
          const msgObj = JSON.parse(msg) //获取并转译json字符串为object
          if (msgObj.event === 'enter') {
              ws.name = msgObj.message //将用户信息绑定到ws对象上
          }
          // ws.send('server:' + msg)
          //获取所有的连接的用户
          wss.clients.forEach((client) => {
              if (client.readyState === WebSocket.OPEN) {
                  msgObj.name = ws.name //将用户的name从ws对象中读取出来放在数据中
                  client.send(JSON.stringify(msgObj))
              }
          })
      })
  ```

  最后在客户端上，我们将该用户的信息再次读取出来，并将`name`也显示出来即可；

  ```js
   onMessage(event) {
     if(this.isShow)  return
        var obj = JSON.parse(event.data)
     if(obj.event === 'enter'){
        this.lists.push("欢迎 "+obj.message+" 进入直播间")
     }else{
        //如果返回来的消息是自己发送的就没必要显示消息了
        if(obj.name !== this.name){
           this.lists.push(obj.name+":"+obj.message) //将读取出来的发送消息的用户的name显示出来
        }
     }
   },
  ```

## 统计在线人数

这个功能很简单，首先，我们设定一个计数器，然后当用户进入聊天室时我们就将该计数器加一，接着在每一次服务器发送消息到客户端时连带该消息即可；

> 需要每一次在线人数变动时都单独主动发送一条消息来告知用户在线人数变动了吗？其实是没有必要的，因为只要一个用户进入了聊天室，就会发送一条用户进入聊天室的消息，这时候也会连带在线人数的信息；

```js
...

let num = 0; //计数器

//当新的连接连接过来时触发回调
wss.on('connection', function connection(ws) {
    console.log('client is connected to Server')
    //对当前的连接进行监听,msg是传递的message内容
    ws.on('message', function (msg) {
        const msgObj = JSON.parse(msg)
        if (msgObj.event === 'enter') {
            ws.name = msgObj.message //将用户信息绑定到连接对象上
            num++; //当用户进入聊天室，更新计数器
        }
        // ws.send('server:' + msg)
        //获取所有的连接的用户
        wss.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
                msgObj.name = ws.name
                // msgObj.num = wss.clients.size 
              //这种方法会统计所有的连接的用户，一般来讲，我们都是当用户处于当前路由页面时，这个连接就会连接上，而用户进入聊天室是需要额外操作的，也就是说即使用户没有进入聊天室，连接的用户也包含了当前用户，因此数据是不可靠的数据
                msgObj.num = num; //将当前在线人数返回回去
                client.send(JSON.stringify(msgObj))
            }
        })
    })
})
```

## 离开聊天室

当用户离开聊天室（比如用户关闭`tab`标签页面）时，连接会被关闭，在服务器侧会触发`close`的连接事件，在这个时候，我们可以发送用户离开聊天室的消息到还连接着的客户端；

```
 //当ws客户端断开连接时
    ws.on('close', () => {
        if (ws.name) num--; //将在线人数减一
        let msgObj = {} 
        wss.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) { //向在线的用户发送消息
                msgObj.name = ws.name //将当前用户的信息
                msgObj.num = num;  //发送新的在线人数
                msgObj.event = 'out' //设置消息类型为out事件
                client.send(JSON.stringify(msgObj))
            }
        })
    })
```

然后在客户端去显示消息即可；

```js
  onMessage(event) {
    if(this.isShow)  return
   		 var obj = JSON.parse(event.data)
    if(obj.event === 'enter'){
   		 ...
    } else if(obj.event === 'out'){ //如果是用户退出聊天室的消息
  		  this.lists.push(`${obj.name} 已经退出了聊天室`)
    }
    else{
  		 ...
    }
    this.num = obj.num
  },
```

## 多聊天室

多聊天室的实现很简单；

首先，我们设置一个存储所有聊天室的在线人数的对象，如:

```
let group = {
   "1": 100, //代表聊天室1的人数有100人
}
```

接着，每一个聊天室都有一个`roomId`，当用户进入聊天室时，会连带着用户要进入的聊天室的`roomId`到服务器上，然后我们将当前连接所指向的`roomId`存储到该用户的连接上，同时更新`group`中的对应`roomId`的在线人数；

如果在`group`中该`room`不存在，我们就创建这个`room`的数据；

同时，我们需要发送消息到对应聊天室中，而不是发送到每一个聊天室；

```js
 //对当前的连接进行监听,msg是传递的message内容
    ws.on('message', function (msg) {
        const msgObj = JSON.parse(msg)
        if (msgObj.event === 'enter') {
            ws.name = msgObj.message //将用户信息绑定到连接对象上
            ws.roomId = msgObj.roomId //将用户roomId绑定到对象上
            if (typeof group[ws.roomId] === 'undefined') {
                group[ws.roomId] = 1
            } else {
                group[ws.roomId]++
            }
        }
        // ws.send('server:' + msg)
        //获取所有的连接的用户
        wss.clients.forEach((client) => {
            //如果当前用户的roomId和client的roomId一致，那么就把当前消息发送给他
            if (client.readyState === WebSocket.OPEN && client.roomId === ws.roomId) {
                msgObj.name = ws.name
                // msgObj.num = wss.clients.size
                msgObj.num = group[ws.roomId];
                client.send(JSON.stringify(msgObj))
            }
        })
    })
```

同时，当用户退出当前聊天室时，我们要更新聊天室的在线人数，并且发送有用户退出聊天室的消息到该聊天室中；

```js
 //当ws客户端断开连接时
    ws.on('close', () => {
        if (ws.name) {
            group[ws.roomId]--;
        };
        let msgObj = {}
        wss.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN && client.roomId === ws.roomId) {
                msgObj.name = ws.name
                // msgObj.num = wss.clients.size
                msgObj.num = group[ws.roomId]
                msgObj.event = 'out'
                client.send(JSON.stringify(msgObj))
            }
        })
    })
```

# [`WebSocket`]进步功能

## `WebSocket`鉴权

当用户进入页面，`webSocket`就会进行连接，而无关用户是否具有进入的权限，比如在用户没有登陆时，我们不希望用户可以进入聊天室；那么我们要怎么做呢？

我们第一个想法就是在我们发送请求去创建一个`WebSocket`连接时传递用户`token`到服务器上，来检验`token`的正确性；

我们知道，我们的`socket`需要使用`http`进行协议`upgrade`，这样我们才能完成创建和客户端的`socket`连接，因此我们可以在`http`上添加对`upgrade`即协议升级事件进行监听，在监听的回调函数中（虽然协议已经升级为`socket`协议，但是`webSocket`还没有连接）我们进行鉴权，来选择是否将该用户与`socket`服务器连接；

> 实际上，`ws`在服务器端上的默认配置会调用`http`的库来创建`3000`端口的`ws`服务器；
>
> 更进一步地，在默认创建`ws`服务器的过程中，当`upgrade`事件触发并完成`http upgrade`升级协议时，会自动调用下面的函数将当前的请求组织成一个`ws`客户端对象，然后触发`connection`事件；
>
> ```js
>  server.on('upgrade', function upgrade(request, socket, head) {
>    //当htt升级完成时，会触发回调，我们将这些数据都传递给handleUpgrade函数生成一个ws对象代表当前用户
>    wss.handleUpgrade(request, socket, head, function done(ws) {
>           //触发连接事件
>           wss.emit('connection', ws, request);
>       })
>  }
> ```

因此我们现在需要自定义连接，但是我们需要更改一下配置；

```js
const WebSocket = require('ws') //引用库
const http = require('http')
const server = http.createServer()
const wss = new WebSocket.Server({
    noServer: true //由于要将WebSocket连接到http上，因此设置为不单独创建server
})

...

//当新的连接连接过来时触发回调
wss.on('connection', function connection(ws) {
 ...
})

//http请求升级回调
//request: {http.IncomingMessage} The client HTTP GET request，传递请求的Get请求对象传递进去
//socket:{net.Socket} The network socket between the server and client. 
//TCP协议是socket协议的基础，net.Socket是对浏览器客户端一端的抽象，是进程通信的客户端，因此我们必须传递进来才能对此创建连接，更多信息参考http://nodejs.cn/api/net.html#net_class_net_socket
 //head: {Buffer} The first packet of the upgraded stream. 是一个Buffer的实例，是升级完成后的updated Stream的第一个数据包
server.on('upgrade', function upgrade(request, socket, head) {
    console.log("upgrade -> request", request)
  //在此处可以进行鉴权
  //使用传入的这些对象生成一个ws客户端
    wss.handleUpgrade(request, socket, head, function done(ws) {
        wss.emit('connection', ws, request); //触发连接事件，将该用户添加到连接中
    })
})


server.listen(3000) //http监听
```

以上，我们提供了最基本的框架，现在我们需要获取浏览器端传递过来的`token`来进行鉴权，那么要怎么传？最广泛的方法就是这么传递：

```html
<script>
//参数2代表子协议，subprotocols
this.ws = new WebSocket('ws://127.0.0.1:3000',null,{
  headers:{
      token:'xxx'
  }
})
</script>
```

但是实际上，这个连接是不会在`headers`中带上`token`的，因为浏览器端的`ws`根本就不支持这个参数，因此这个方法不可行；

但是在`node.js`侧，是不会出现这样的问题的，我们倒是可以直接传递`headers`；

```js
const WebSocket = require('ws')
const ws = new WebSocket('ws://127.0.0.1:3000', {
    headers: {
        token: '123'
    }
})
```

如下图，我们在`server.on('upgrade')`回调函数的`request`对象的`rawHeaders`对象下获得了`token`数据；

<img src="/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-25 01.00.25.png" alt="截屏2020-08-25 01.00.25" style="zoom:50%;" />

为什么同一个库在不同平台出现不同的表现？其实是`ws`库在浏览器侧自动降级了，关闭了一些选项；

在此基础上，我们要怎么做才能对浏览器端的`socket`进行鉴权呢？那就只剩下一个办法-----在连接的`url`上添加鉴权的参数，然后在`http.upgrade`事件的回调函数中获取`url`参数中的鉴权数据，最后进行鉴权即可；

```js
server.on('upgrade', function upgrade(request, socket, head) {
    console.log("upgrade -> request", request)
  //在此处可以进行鉴权
  //使用传入的这些对象生成一个ws客户端
    wss.handleUpgrade(request, socket, head, function done(ws) {
        wss.emit('connection', ws, request); //触发连接事件，将该用户添加到连接中
    })
})
```

这是第一种想法，那么在浏览器端，还有什么方法可以使用呢？

第二种方法，`ws`有一个`onOpen`的监听函数，当连接打开后，我们可以传递这样一个事件给服务器（如果使用这种方法，前面的所有啰嗦操作都不需要，最简洁）：

```js
 onOpen() {
   //在连接open时，我们发送消息到服务器上进行鉴权
   this.ws.send(JSON.stringify({
     event:'auth',
     message:'xxxx'//token
   }))
 },
```

然后在我们的服务器上这样做：

```js
const jwt = require('jsonwebtoken')
... 
ws.on('message', function (msg) {
    const msgObj = JSON.parse(msg)
    if (msgObj.event === 'enter') {
      ...
    } else if (msgObj.event === 'auth') { //当事件名为auth时，我们进行鉴权
      //鉴权
      jwt.verify(msgObj.message, 'secret', (err, decode) => {
        if (err) {
          //websocket返回前台消息
          console.log('auth error')
          ws.auth = false
          return
        } else {
          console.log(decode)
          ws.auth = true
          return
        }
      })
    }
    //如果鉴权失败
    if (!ws.isAuth) {
      //发送鉴权失败的消息到浏览器
      ws.send(
        JSON.stringify({
          event: 'noauth',
          message: 'please auth again',
        })
      )
      return
    }
    ...
  })
```

最后在浏览器端接收这个消息处理一下就行，比如重定向路由到用户登陆页面，或者直接关闭连接；

```
 onMessage(event) {
   if(this.isShow)  return
   var obj = JSON.parse(event.data)
   if(obj.event === 'noauth'){
     //鉴权失败
     //路由跳转/login 重新获取token
   }
   ...
 },
```

这样我们就完成了鉴权的流程；

对于可用的鉴权方案，总结如下：

+ 在浏览器端，协议本身在握手阶段不提供鉴权方案；

+ 浏览器侧：`url`传参、`message`主动消息、`session/cookie`（前后端分离不建议使用）；
+ `Node.js`侧：直接使用`ws`传`Headers`；

## 心跳检测

在`webSocket`的应用中，由于网络环境的问题，可能出现`WebSocket`连接断开的情况，因此我们必须要进行心跳检测，来保证我们的`WebSocket`应用是连接畅通的；

方法也很简单；

第一步，当我们的客户端与服务器端的`WebSocket`建立了连接时，那么我们就首先设置当前这个连接是处于`active`的状态，说明连接是开放的；

```
wss.on('connection', function connection(ws) {
  //默认激活状态
  ws.isActive = true
  ...
}
```

第二步，我们设定一个定时器，每过一定间隔时间，我们就设置每一个客户端的连接处于`not active`的状态，然后立刻往该用户的浏览器侧发送一个消息，告诉浏览器`"我要知道你是不是活着的"`；在下一轮的对每一个用户的进行心跳检测之前，如果这个连接还是处于`not active`的状态，说明这个客户端真的死了，所以可以直接在服务器端结束连接；

```
const timeInterval = 1000
//每隔一段时间就发送心跳检测
setInterval(() => {
  wss.clients.forEach((ws) => {
    //主动发送新跳检测消息
    if (!ws.isActive) {
      group[ws.roomId]--
      return ws.terminate() //说明超过1s钟客户端没有相应，那么就终止该终端的连接
    }
    //当客户端返回了消息之后，主动设置flag为在线
    ws.isActive = false
    ws.send(
      JSON.stringify({
        event: 'heartbeat',
        message: 'ping',
        num: group[ws.roomId],
      })
    )
  })
}, timeInterval)
```

第三步，如果浏览器侧是活着的，那么在用户的客户端就能得到这个心跳检测的消息：

```
case 'heartbeat':
  this.ws.send(JSON.stringify({
    event:'heartbeat',
    message:'pong'
  }))
break;
```

得到后我们就返回一个心跳消息给服务器，在服务器得到这个心跳消息后，对于服务器来说，一次心跳检测就完成了，就将用户的连接状态重新设置为`active`状态；

每一轮定时器都会进行这样的过程，直到客户端断开了连接，比如关闭了标签页面；

## 断线重连

心跳检测用于告诉服务器端浏览器是不是还活着，断线重连用于不断地去重新连接服务器，这是两个不同的范畴；

我们什么时候断线重连？

当浏览器端获取了服务器端的心跳检测的消息后，浏览器端就会去发送一条心跳消息给服务器端；

但是我们不确定下一次服务器是不是会挂掉，如果下一次服务器没有发送心跳检测的消息，那么说明服务器断线了，如果发送了，那么说明连接一切正常；

由于服务器端心跳检测的时间间隔为`1000ms`，此外网络的延时大致为`500ms~1000ms`左右，因此最迟的心跳检测大致在浏览器心跳消息发送后的`1500ms～2000ms`左右，那么我们从浏览器端发送心跳消息给服务器端开始算`2000ms`时间，如果这段时间之内有新的心跳检测消息，那么说明连接正常，超过`2000ms`左右时间说明断线；

如果断线了也非常好处理，我们关掉当前的连接，再连接一次；

```js
 case 'heartbeat':
   //发送了心跳消息，从发送后开始，我们开始进行断线重连的检测
   this.ws.send(JSON.stringify({
     event:'heartbeat',
     message:'pong'
   }))
   this.checkServer()
 break;
 
 ...
 
onClose() {
   console.log('close :' + this.ws.readyState)
   console.log('close the socket connection.')
   this.ws.close()
},
   
init(){
   this.ws = new WebSocket('ws://127.0.0.1:3000')
   this.ws.onopen = this.onOpen
   this.ws.onmessage = this.onMessage
   this.ws.onerror = this.onError
   this.ws.onclose = this.onClose
},
 
checkServer(){
   var _this = this //由于setTimeout的this指向问题，需要在外侧重新定义来引用
   clearTimeout(this.handle) //当下一次心跳检测的消息到达时，如果这时候延时器还没有结束，那么就把它删掉
   this.handle = setTimeout(function(){ 
     _this.onClose() //2000ms后如果心跳检测的消息还没有到达就关闭socket连接
     _this.init() //重新建立一个连接
   },1000+1000)
}
```

历史的完整的代码如下：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="http://cdn.staticfile.org/vue/2.6.12/vue.min.js"></script>
    <title>Document</title>
  </head>

  <body>
    <div id="app">
        <div v-if="isShow">
                    <p>昵称: <input type="text" v-model="name"></input></p>
                    <p>房间号: <input type="text" v-model="roomId"></input></p>
                    <button type="button" @click="enter()">进入聊天室</button>
        </div>
        <div v-else>
              <ul>
                  <li v-for="(item , index) in lists" :key="'message'+index">{{item}}</li>
                  <li>在线人数:{{num}}</li>
              </ul>
              <div class="ctrl">
                  <input type="text" id="msg" v-model="message" />
                  <button type="button" id="send" @click="send()">发送</button>
                  <button type="button" id="close">关闭连接</button>
              </div>
        </div>  
    </div>
    <script>
      var app = new Vue({
        el: '#app',
        data: {
          message: '',
          lists: [],
          ws: {},
          name:"",
          isShow:true,
          num:0,
          roomId:"",
          handle:{}
        },
        mounted() {
        },
        methods: {
          //建立连接
         init(){
            this.ws = new WebSocket('ws://127.0.0.1:3000')
            this.ws.onopen = this.onOpen
            this.ws.onmessage = this.onMessage
            this.ws.onerror = this.onError
            this.ws.onclose = this.onClose
          },
          enter(){    
                if(this.name.trim() === ''){
                    alert('用户名不得为空')
                    return;
                }
                this.init()  
            },
          onOpen() {
              //连接打开时首先进行鉴权，如果鉴权失败，该用户也不能加入
             this.ws.send(JSON.stringify({
                event:'auth',
                message:'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6InNvbGluZ2plZXMiLCJpYXQiOjE1MTYyMzkwMjJ9.oBGweuKZibcXy0MSL5Ra-InyAQXh1snxgHVWGdY4rT8'
                }))
             //发送文本字符串、底层二进制数据、Blob，但是不能发送对象
             //发送进入聊天室的请求
             this.ws.send(JSON.stringify({
                event:'enter',
                message: this.name,
                roomId:this.roomId
             }))
    
          },
          //接受到服务器传递回来的event对象，event.data是服务器传递回来的数据
          onMessage(event) {
            var obj = JSON.parse(event.data)
            switch(obj.event){
                case 'auth':
                    break;
                case 'noauth':
                    this.isShow = true
                    this.ws.close()
                    break;
                case 'enter':
                    this.lists.push("欢迎 "+obj.message+" 进入直播间")
                    if(obj.message === this.name)
                        this.isShow = false
                    break;
                case 'out':
                    this.lists.push(`${obj.name} 已经退出了聊天室`)
                    break;
                case 'heartbeat':
                    this.ws.send(JSON.stringify({
                        event:'heartbeat',
                        message:'pong'
                    }))
                    this.checkServer()
                    break;
                default:
                    if(obj.name !== this.name){
                       this.lists.push(obj.name+":"+obj.message)
                    }
            }
            this.num = obj.num
          },
          onClose() {
            console.log('close :' + this.ws.readyState)
            console.log('close the socket connection.')
            this.ws.close()
          },
          onError() {
            console.log('error' + this.ws.readyState)
            console.log('连接失败')
            var _this = this
            setTimeout(function(){
               _this.init()
            },1000)
          },
          send() {
            this.lists.push(this.name+":"+this.message)
            this.ws.send(JSON.stringify(
            {
                event:'message',
                message:this.message,
            }
            ))
            this.message = ''
          },
          checkServer(){
              var _this = this
              clearTimeout(this.handle)
              this.handle = setTimeout(function(){
                _this.onClose()
                _this.init()
              },1000+500) //时间要和服务器的心跳检测的间隔一致
          }
        },
      })
    </script>
  </body>
</html>

```

当然，这么繁琐细碎的做心跳检测和断线重连很让人烦恼呢：

+ 如果你在`es5`语法环境下编程，那么可以使用`ReconnectingWebSocket`这个库，它对`WebSocket`有一层断线重连的封装；

+ 如果你在`es6`语法环境下编程，那么可以使用`reconnecting-webSocket`这个库，和前者是一致的；

# [`WebSocket`]消息缓存

## 业务逻辑

我们的用户的消息需要缓存下来，要不然每一次用户进到聊天室里都是空的，这是非常不合常理的，也是用户体验很糟糕的；

一般我们会将当前聊天室对于一个用户还没有阅读的消息缓存在`redis`中，因为这种数据，往往需要高速的处理，特别是直播软件，会有大量的这种消息；

当这个用户进入聊天室后，我们就将该用户没有阅读的消息返回给用户终端，并且清空`redis`中该用户的缓存的消息；

那么如何进行消息缓存呢？就流程图来说，还是有一定复杂程度的，但是实际上处理起来并不是很费劲；

<img src="/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-26 23.21.13.png" alt="截屏2020-08-26 23.21.13" style="zoom:50%;" />

基于此，我们要确定`redis`的数据结构；

由于`redis`使用键值对的形式进行存储，因此我们只需要建立两种键值对即可；

一种是`roomID`为键、以该聊天室内的所有的用户`userID`字符串的键值对，这个键值对表示所有来到过该聊天室内的用户，包括当前在线的用户和已经离线的用户；

另一种比较复杂，对于一个聊天室来说，一个用户发送了一条消息到聊天室中，但是实际上可能有些用户因为离线了的原因而不会接收到我的消息；这时候我就将我的消息缓存到一个以这个没有读取到我的消息的用户的`uid`为键、以保存所有该用户没有阅读的消息的对象数组的字符串序列化为值的键值对中，这个键的值的结构如下：

```js
{
   "uid":"2", //表示这条消息该用户没有阅读
   "roomId":"xx", //表示这条消息是属于哪个聊天室的，因为一个用户可能进入了好几个聊天室
   "msg"://该用户没有的阅读的消息内容
}
```

下图是形象化的图示：



![截屏2020-08-26 23.36.26](/Users/sulingjie/Library/Application Support/typora-user-images/截屏2020-08-26 23.36.26.png)

## 进入聊天室

在我们的应用中，我们是这样设计的，当用户没有选择要进入的聊天室、没有输入自己的`uid`和`nickname`之前，我们的`socket`连接不会发生，当用户这些操作都完成并确认之后，用户按下`进入聊天室按钮`就会与我们的`socket`产生连接（但是这些信息都还没有使用），连接完成后，客户端就会发送`enter`消息（真正将用户数据存入服务器端）来进入聊天室；

因此我们会在用户发送`enter`消息进入聊天室的时候，来做进入聊天室的操作；

在用户进入聊天室的时候，前端发送的`enter`消息的结构如下：

```
{
   event:'enter',
   uid:"12345",
   roomId:"1",
   name:"imx"
}
```

同时，在我们的应用中，我们的聊天室数据是这样存储在`redis`中的；

```js
imooc-<房间号>: "<uid1>,<uid2>,<uid3>..."
```

代码和逻辑其实很简单：当用户要进入的聊天室在`redis`中存在，就将该用户的`uid`追加该聊天室的`value`中，并以`,`字符分隔不同的用户，如果不存在，我们就要新建一个聊天室，并将该用户的`uid`作为其键值；

由于我们需要判断聊天室在`redis`中是否存在，因此需要更新我们操作`redis`的`api`，新增一个确定是否存在用户要进入的聊天室的`api`；

```js
const { promisifyAll } = require('bluebird')
const redis = require('redis')
const client = promisifyAll(redis.createClient(options))

//判断指定key的聊天室是否存在
const existKey = async function (key) {
  const result = await client.existsAsync(key) //使用bluebird将redis所有的api转化为异步函数
  return result
}
```

接着，我们在`enter`消息中使用这个`existKey`方法判断用户所想要进入的聊天室在`redis`中是否存在，如果不存在就使用`redis`的`setValue`方法在`redis`中新建它；核心代码如下：

```js
//判断redis是否对应的roomId的键值
const result = await existKey(roomId)
if (result === 0) {
    //说明没有该键----该聊天室不存在
    //创建聊天室
    setValue(roomId, msgObj.uid) //各个用户以长数组形式存储
} else {
    //该聊天室已经存在
    let arrStr = await getValue(roomId)
    let arrObj = arrStr.split(',')
if (arrObj.indexOf(msgObj.uid) === -1) {
    //该用户不存在于该聊天室中
    setValue(roomId, arrStr + ',' + ws.uid)
}
}
```

这样我们就将当前用户成功添加到用户要进入的聊天室里了，具体代码如下：

```js
 case 'enter':
        //  if (!ws.auth) {
        if (ws.auth) {
        } else {
          ws.name = msgObj.message //将用户信息绑定到连接对象上
          ws.roomId = msgObj.roomId //将用户roomId绑定到对象上
          ws.uid = msgObj.uid //将用户的id也绑定到对象上
          console.log('connection -> uid', ws.uid)
          //判断redis是否对应的roomId的键值
          const result = await existKey(roomId)
          if (result === 0) {
            //说明没有该键----该聊天室不存在
            //创建聊天室
            setValue(roomId, msgObj.uid) //各个用户以长数组形式存储
          } else {
            //该聊天室已经存在
            let arrStr = await getValue(roomId)
            let arrObj = arrStr.split(',')
            if (arrObj.indexOf(msgObj.uid) === -1) {
              //该用户不存在于该聊天室中
              setValue(roomId, arrStr + ',' + ws.uid)
            }
          }
          if (typeof group[ws.roomId] === 'undefined') {
            group[ws.roomId] = 1
          } else {
            group[ws.roomId]++
          }
        }
        break
```

## 离线消息缓存、用户进场获取缓存消息（重点）

首先，我们要解释什么情况下我们需要进行离线缓存。当我（一个在线的用户）在聊天室内发送了一条消息，那么自然地，我希望将消息发到每一个这个聊天室的每一个用户终端，但是往往有用户是不在线的，那么我就要将我们发的消息缓存下来，当他上线了，消息会自动出现在它的终端上；

那么要怎么做呢？

首先，当我们的一则简单的`message`类型的消息发送出去后并到达服务器后，我们需要遍历所有的在当前我所在的聊天室内的有过登记记录的用户；如果这个用户处于离线状态了，我们就要去缓存消息了；

在缓存消息之前，我们需要获取到所有的在这个聊天室内的用户；

```
    //获取房间里所有的用户
    let arrStr = await getValue(roomId)
    //存储当前聊天室所有离线的用户
    const users = arrStr.split(',')
```

`users`数组在这里目前包含了当前聊天室内所有的用户，但是我们需要全部离线的用户，因此会在用户遍历时将这些在线的用户给剔除掉，这部分内容之后讲解，现在暂时就理解为`users`包含所有离线的用户；

那么问题来了，怎么缓存消息？

我们要在`redis`中存储一个键值对，这个键值的键就是这个用户的`uid`，值被设计为一个被字符串序列化的长对象数组，每一个数组元素包含以下但不限以下内容：

```
{
   "event":"message",
   "message":"xxx",
   "num":"1",
   "roomId":"1",
   "name":"xx"
}
```

因为这个用户是处于离线状态的，因此我们将我们的消息存储在他的键值对下，这样它下一次进入这个聊天室内时就可以读取它没有阅读的消息了；

那么首先，我们需要遍历所有的没有在线的用户，同时要保证这个用户的键值对是存在的，如果不存在就在这次新建它；

接着，我们就将我们这次的消息存储到这个键值对中就行了；

```js
//断开了与服务端连接的用户的id信息，并且其他的客户端发送了消息
    if (users.length > 0 && msgObj.event === 'message') {
      users.forEach(async function (item) {
        const result = await existKey(item)
        if (result !== 0) {
          //该用户已经存在了
          let userData = await getValue(item)
          let msgs = JSON.parse(userData)
          msgs.push({
            roomId: ws.roomId,
            ...msgObj,
          })
          setValue(item, JSON.stringify([msgs]))
        } else {
          setValue(
            item,
            JSON.stringify([
              {
                roomId: ws.roomId,
                ...msgObj,
              },
            ])
          )
        }
      })
    }
```

这样我们就完成了消息的缓存，下一个问题，这个离线的用户下一次登陆时怎么获取这些消息；

因为在我们的应用中，当一个用户进入了聊天室，我们需要将`enter`消息发送给所有在线的用户，在这时候，我们首先需要剔除这些在线的用户，防止之后错误地将缓存消息存储给他们；

```js
ws.on('message', async function (msg) {
    const msgObj = JSON.parse(msg)
    ...
    //遍历所有的用户
    wss.clients.forEach(async (client) => {  
      if (client.readyState === WebSocket.OPEN && client.roomId === ws.roomId) {
            msgObj.name = ws.name
            msgObj.num = group[ws.roomId]
            client.send(JSON.stringify(msgObj)) //发送enter消息
            //这个用户在当前聊天室在线，那么我们的这条消息就是发到这个用户了，排除在离线用户数组
            if (users.indexOf(client.uid) !== -1) {
              users.splice(users.indexOf(client.uid), 1)
            }
            ...
      }
    }
    ...
}
```

我们遍历这些在线的用户，如果当前遍历到的是自己，那么就去看看自己有没有在当前聊天室缓存的消息，要想知道有没有很简单，就是从`redis`里拿到自己的键值对，然后读取内容就知道自己未读取的消息了；

如果有，我们就读取出来并发给自己的终端，接着更新我们的未读取的消息，因为你只是读了当前这个聊天室的消息，其他聊天室的消息都没有读取过，所以不能全部清除，而是更新；

这样我们就完成了消息的读取，具体实现如下；

（下面的实现，其实并不推荐，我之前看的时候也是云里雾里，最后猛然发现这不是一个好的结构）；

```js
       //取redis中的uid数据
        let result = await existKey(ws.uid)
        if (result !== 0) {
          //我有自己没有阅读的数据
          let tmpArr = await getValue(ws.uid)
          //所有我没有看的数据
          let tmpObj = JSON.parse(tmpArr)
          let uid = ws.uid
          if (tmpObj.length > 0) {
            let i = []
            tmpObj.forEach((item) => {
              //如果遍历到我自己了，就先看看是不是当前这个聊天室的，如果是，将当前这个消息直接发给自己
              if (item.roomId === ws.roomId && uid === client.uid) {
                client.send(JSON.stringify(item))
                i.push(item)
              }
            })
            if (i.length > 0) {
              i.forEach((item) => {
                tmpObj.splice(item, 1)
              })
            }
            setValue(ws.uid, JSON.stringify(tmpObj))
          }
        }
```

我修改了结构，还是这个实现好一些，并且有一定的性能上的优势（之前的实现不管这个用户是不是自己，都从`redis`拿了自己的未读消息）：

```js
if (ws.uid === client.uid) {
          //取自己的数据
          let result = await existKey(ws.uid)
          //如果自己的对象存在
          if (result !== 0) {
            //获取自己的数据
            let tmpArr = await getValue(ws.uid)
            //所有我没有看的数据
            let tmpObj = JSON.parse(tmpArr)
            let uid = ws.uid
            if (tmpObj.length > 0) {
              let i = [] //返回的需要被删除的消息
              tmpObj.forEach((item) => {
                //如果这条数据是这个聊天室的
                if (item.roomId === ws.roomId) {
                  client.send(JSON.stringify(item))
                  i.push(item)
                }
              })
              if (i.length > 0) {
                i.forEach((item) => {
                  tmpObj.splice(item, 1)
                })
              }
              setValue(ws.uid, JSON.stringify(tmpObj)) //更新未读消息
            }
          }
        }
```

这样我们就完成了离线消息缓存和上线读取；













